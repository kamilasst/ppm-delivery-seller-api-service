name: Java CI com Maven e PostgreSQL

# Dispara o workflow em Pull Requests direcionados à branch 'main'
on:
  pull_request:
    branches: [ main ] # Ou sua branch padrão, ex: master

jobs:
  build-and-test:
    runs-on: ubuntu-latest # Utiliza a última versão do Ubuntu como runner

    steps:
    - name: Checkout do repositório
      uses: actions/checkout@v4 # Ação para baixar o código do seu repositório

    - name: Configurar JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin' # Distribuição do JDK (Temurin é uma boa escolha)

    - name: Cache de pacotes Maven
      uses: actions/cache@v4
      with:
        path: ~/.m2/repository # Caminho onde o Maven armazena as dependências baixadas
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }} # Chave de cache baseada no SO e no hash do pom.xml
        restore-keys: | # Chaves de restauração alternativas
          ${{ runner.os }}-maven-

    - name: Iniciar container PostgreSQL com Docker Compose
      run: docker-compose up -d postgres
      # Este comando utiliza o arquivo 'docker-compose.yml' na raiz do seu repositório.
      # O serviço 'postgres' definido no seu docker-compose.yml será iniciado.

    - name: Aguardar PostgreSQL ficar pronto
      run: |
        echo "Aguardando o PostgreSQL iniciar..."
        # Loop para verificar a prontidão do PostgreSQL por até 30 segundos.
        # Ele tenta se conectar usando 'pg_isready' dentro do container do postgres.
        # O usuário padrão para a imagem postgres é 'postgres'.
        for i in {1..15}; do
          if docker exec $(docker-compose ps -q postgres) pg_isready -U postgres -d database-seller -h localhost; then
            echo "PostgreSQL está pronto."
            exit 0
          fi
          sleep 2
        done
        echo "PostgreSQL não ficou pronto a tempo."
        exit 1
      # NOTA: Se seus testes utilizam Testcontainers exclusivamente para o PostgreSQL,
      # este passo explícito de 'docker-compose up' e a espera podem ser redundantes,
      # pois o Testcontainers gerenciará suas próprias instâncias de banco de dados.
      # No entanto, se algum teste espera um BD em localhost:5432 conforme o docker-compose, este passo é necessário.

    - name: Rodar testes unitários com Maven
      run: mvn -B test
      # Certifique-se de que seu arquivo src/test/resources/application.properties (ou propriedades específicas de perfil)
      # esteja configurado para conectar ao banco de dados PostgreSQL, caso seus testes não usem Testcontainers para isso:
      # Exemplo de configuração para application-test.properties:
      # spring.datasource.url=jdbc:postgresql://localhost:5432/database-seller
      # spring.datasource.username=postgres # Usuário padrão da imagem postgres, a menos que POSTGRES_USER esteja definido
      # spring.datasource.password=123456
      # spring.jpa.hibernate.ddl-auto=create-drop # ou validate, update para testes

    # Opcional: Parar os serviços do Docker Compose explicitamente.
    # O ambiente do runner é geralmente limpo automaticamente.
    # - name: Parar serviços
    #   if: always() # Garante que este passo rode mesmo se os anteriores falharem
    #   run: docker-compose down